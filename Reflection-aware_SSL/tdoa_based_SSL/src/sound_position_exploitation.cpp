#include <ros/ros.h>
#include <stdlib.h>
#include <stdio.h>
#include <string>
#include <fstream>

#include <tf/tf.h>

#include <geometry_msgs/PoseStamped.h>
#include "tdoa_based_ssl_message/PotentialSources.h"


namespace{
    static const std::string robot_frame_s = "base_link";

    class SourcePositionExploitation
    {
    public:
        SourcePositionExploitation(ros::NodeHandle& nh) : nh_local_("~")
        {
            pose_pub_ = nh.advertise<geometry_msgs::PoseStamped>("potential_sources_pose", 100);

            potential_sources_write_file = fopen("/home/inkyuan/catkin_ws/src/find_invisible_obstacle/localization/data/soundPositiondata.txt", "w");
            if(potential_sources_write_file == NULL)
                ROS_INFO("../data/soundPositiondata.txt can not be opened");
            else
                ROS_INFO("../data/soundPositiondata.txt opened");

            nh_local_.param("min_latitude", min_latituede_, -60.0);           

            potential_sources_sub_ = nh.subscribe("Potential_Sources", 100, &SourcePositionExploitation::potentialSourcesCallback, this);
        }
        ~SourcePositionExploitation()
        {
            if(potential_sources_write_file != NULL)
                fclose(potential_sources_write_file);
        }
    private:
        void potentialSourcesCallback(const tdoa_based_ssl_message::PotentialSourcesConstPtr& sources_ptr)
        {
            static const double PI = 3.14159;

            geometry_msgs::PoseStamped pose_msg;
            pose_msg.header.stamp = sources_ptr->header.stamp;
            pose_msg.header.frame_id = sources_ptr->header.frame_id;

            int nb_sources = sources_ptr->potential_sources.size();
            float max_e = -1.0;

            fprintf(potential_sources_write_file, "%d ", sources_ptr->header.stamp.nsec);

            for(int i=0 ; i<nb_sources; i++)
            {
                fprintf(potential_sources_write_file, "%d %f %f %f %f %f %f "
                        , sources_ptr->potential_sources[i].source_id
                        , sources_ptr->potential_sources[i].source_pos.x
                        , sources_ptr->potential_sources[i].source_pos.y
                        , sources_ptr->potential_sources[i].source_pos.z
                        , sources_ptr->potential_sources[i].latitude
                        , sources_ptr->potential_sources[i].longitude
                        , sources_ptr->potential_sources[i].source_probability
                        );

                if(sources_ptr->potential_sources[i].latitude < min_latituede_)
                    continue;
                const float& e = sources_ptr->potential_sources[i].source_probability;

                if (max_e < e)
                {
                    max_e = e;
                    pose_msg.pose.position = sources_ptr->potential_sources[i].source_pos;
                    tf::Quaternion r;
                    r.setRPY(
                        0,
                        -1.0 * sources_ptr->potential_sources[i].latitude / 180.0 * PI,
                        sources_ptr->potential_sources[i].longitude / 180.0 * PI);

                    tf::quaternionTFToMsg(r, pose_msg.pose.orientation);
                }

            }            
            fprintf(potential_sources_write_file, "\n");

            if (max_e >= 0.8)
                pose_pub_.publish(pose_msg);
        }


    ros::Publisher pose_pub_;
    ros::Subscriber potential_sources_sub_;
    ros::NodeHandle nh_local_;
    tdoa_based_ssl_message::PotentialSources potential_sources_fr[4];

    FILE* potential_sources_write_file = NULL;

    double min_latituede_;
    };
}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "PS_position_exploitation");
    ros::NodeHandle n;

    ROS_INFO(">> sound_position_exploitation.cpp is starting");

    SourcePositionExploitation spe(n);
    ros::spin();
    return 0;
}
